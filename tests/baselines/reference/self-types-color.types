=== tests/cases/compiler/self-types-color.ts ===
type Color =
>Color : Color

  self extends string
    ? ParseColor<self> extends infer R
      ? R extends { error: infer E extends string }
>error : E

          ? Never<[`Type '${Print<self>}' is not assignable to type 'Color'`, E]>
          : R
      : never
    : string

const t0: Color = 123
>t0 : Color
>123 : 123

const t1: Color = "hello" as string
>t1 : Color
>"hello" as string : string
>"hello" : "hello"

const t2: Color = "#fff"
>t2 : Color
>"#fff" : "#fff"

const t3: Color = "#ffz"
>t3 : Color
>"#ffz" : "#ffz"

const t4: Color = "rgb(100, 1000, 100)"
>t4 : Color
>"rgb(100, 1000, 100)" : "rgb(100, 1000, 100)"

const t5 = "#fff" satisfies Color
>t5 : "#fff"
>"#fff" satisfies Color : "#fff"
>"#fff" : "#fff"

const t6 = "#ffz" satisfies Color
>t6 : "#ffz"
>"#ffz" satisfies Color : "#ffz"
>"#ffz" : "#ffz"

const t7 = "#fff" as Color
>t7 : Color
>"#fff" as Color : Color
>"#fff" : "#fff"

const t8 = "#ffz" as Color
>t8 : Color
>"#ffz" as Color : Color
>"#ffz" : "#ffz"

const t9 = "this is fine" as Color
>t9 : Color
>"this is fine" as Color : Color
>"this is fine" : "this is fine"

const t10 = 0 as Color
>t10 : Color
>0 as Color : Color
>0 : 0


type ParseColor<T> =
>ParseColor : ParseColor<T>

  S.IsStringLiteral<T> extends false ? { error: "Expected a string literal" } :
>S : any
>false : false
>error : "Expected a string literal"

  T extends NamedColor ? T :
  T extends `#${string}` ? ParseHexColor<T> :
  T extends `rgb${string}` ? ParseRgbColor<T> :
  { error: "Expected it to start with '#' or 'rgb' or be a named color" }
>error : "Expected it to start with '#' or 'rgb' or be a named color"


type ParseHexColor<T, I = 0, C = S.At<T, I>> =
>ParseHexColor : ParseHexColor<T, I, C>
>S : any

  [I, C] extends [4, ""] | [7, ""] ? T :
  I extends 0 | 1 | 2 | 3 | 4 | 5 | 6
    ? C extends (I extends 0 ? "#" : Hexadecimal)
      ? ParseHexColor<T, N.Increment<I>>
>N : any

      : { error: `Expected ${I extends 0 ? "#": "an hexadecimal character"} got '${S.Cast<C>}' at column ${I}` } :
>error : `Expected ${I extends 0 ? "#" : "an hexadecimal character"} got '${A.Cast<C, string>}' at column ${I}`
>S : any

  { error: `Unexpected character at ${N.Cast<I>}` }
>error : `Unexpected character at ${A.Cast<I, number>}`
>N : any


type Hexadecimal =
>Hexadecimal : "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F"

  ( "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
  | "a" | "b" | "c" | "d" | "e"| "f"
  ) extends infer X
    ? X | Uppercase<S.Cast<X>>
>S : any

    : never

type ParseRgbColor<T> =
>ParseRgbColor : ParseRgbColor<T>

  T extends `rgb${infer S}`
    ? S extends `(${infer S}`
        ? ParseNumberLessThanOrEqual<S.TrimedL<S>, 255> extends infer X
>S : any

            ? X extends { error: infer E } ? { error: `${S.Cast<E>} for red` } :
>error : E
>error : `${A.Cast<E, string>} for red`
>S : any

              X extends { rest: infer S } ?
>rest : S

                S.TrimedL<S> extends `,${infer S}`
>S : any

                  ? ParseNumberLessThanOrEqual<S.TrimedL<S>, 255> extends infer X
>S : any

                      ? X extends { error: infer E } ? { error: `${S.Cast<E>} for green` } :
>error : E
>error : `${A.Cast<E, string>} for green`
>S : any

                        X extends { rest: infer S } ?
>rest : S

                          S.TrimedL<S> extends `,${infer S}`
>S : any

                            ? ParseNumberLessThanOrEqual<S.TrimedL<S>, 255> extends infer X
>S : any

                                ? X extends { error: infer E } ? { error: `${S.Cast<E>} for blue` } :
>error : E
>error : `${A.Cast<E, string>} for blue`
>S : any

                                  X extends { rest: infer S } ?
>rest : S

                                    S.TrimedR<S> extends `)`
>S : any

                                      ? T
                                      : { error: "Expected ')' after blue value at the end" } :
>error : "Expected ')' after blue value at the end"

                                  never
                                : never
                            : { error: "Expected ',' after green value" } :
>error : "Expected ',' after green value"

                        never
                      : never
                  : { error: "Expected ',' after red value" } :
>error : "Expected ',' after red value"

              never
            : never
        : { error: `Expected '(' got ${S.Cast<S.At<T, 4>>} after rgb` }
>error : `Expected '(' got ${A.Cast<S.At<T, 4>, string>} after rgb`
>S : any
>S : any

    : { error: `Expected 'rgb' at the start` }
>error : "Expected 'rgb' at the start"

type ParseNumberLessThanOrEqual<T, M extends number, N = ParseNumber<T>, V = N["value" & keyof N]> =
>ParseNumberLessThanOrEqual : ParseNumberLessThanOrEqual<T, M, N, V>

  N extends { error: unknown } ? N :
>error : unknown

  Ns.IsLessThanOrEqual<V, `${M}`> extends true ? N :
>Ns : any
>true : true

  { error: `Expected value from '0' to '255' got '${S.Cast<V>}'` }
>error : `Expected value from '0' to '255' got '${A.Cast<V, string>}'`
>S : any
  
type ParseNumber<T, D = ParseDigit<T>> =
>ParseNumber : ParseNumber<T, D>

   D extends { value: infer Nh, rest: infer Sh }
>value : Nh
>rest : Sh

    ? ParseNumber<Sh> extends infer X
        ? X extends { value: infer Nt, rest: infer S }
>value : Nt
>rest : S

            ? { value: `${S.Cast<Nh>}${S.Cast<Nt>}`, rest: S }
>value : `${A.Cast<Nh, string>}${A.Cast<Nt, string>}`
>S : any
>S : any
>rest : S

            : { value: Nh, rest: Sh }
>value : Nh
>rest : Sh

        : never
    : D

type ParseDigit<T> =
>ParseDigit : ParseDigit<T>

  T extends `${0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9}${infer S}`
    ? T extends `${infer V}${S}`
        ? { value: `${V}`, rest: S }
>value : `${V}`
>rest : S

        : never
    : { error: "Expected a number" }
>error : "Expected a number"

type NamedColor =
>NamedColor : "black" | "silver" | "gray" | "white" | "maroon" | "red" | "purple" | "fuchsia" | "green" | "lime" | "olive" | "yellow" | "navy" | "blue" | "teal" | "aqua" | "aliceblue" | "antiquewhite" | "aquamarine" | "azure" | "beige" | "bisque" | "blanchedalmond" | "blueviolet" | "brown" | "burlywood" | "cadetblue" | "chartreuse" | "chocolate" | "coral" | "cornflowerblue" | "cornsilk" | "crimson" | "cyan" | "darkblue" | "darkcyan" | "darkgoldenrod" | "darkgray" | "darkgreen" | "darkgrey" | "darkkhaki" | "darkmagenta" | "darkolivegreen" | "darkorange" | "darkorchid" | "darkred" | "darksalmon" | "darkseagreen" | "darkslateblue" | "darkslategray" | "darkslategrey" | "darkturquoise" | "darkviolet" | "deeppink" | "deepskyblue" | "dimgray" | "dimgrey" | "dodgerblue" | "firebrick" | "floralwhite" | "forestgreen" | "gainsboro" | "ghostwhite" | "gold" | "goldenrod" | "greenyellow" | "grey" | "honeydew" | "hotpink" | "indianred" | "indigo" | "ivory" | "khaki" | "lavender" | "lavenderblush" | "lawngreen" | "lemonchiffon" | "lightblue" | "lightcoral" | "lightcyan" | "lightgoldenrodyellow" | "lightgray" | "lightgreen" | "lightgrey" | "lightpink" | "lightsalmon" | "lightseagreen" | "lightskyblue" | "lightslategray" | "lightslategrey" | "lightsteelblue" | "lightyellow" | "limegreen" | "linen" | "magenta" | "mediumaquamarine" | "mediumblue" | "mediumorchid" | "mediumpurple" | "mediumseagreen" | "mediumslateblue" | "mediumspringgreen" | "mediumturquoise" | "mediumvioletred" | "midnightblue" | "mintcream" | "mistyrose" | "moccasin" | "navajowhite" | "oldlace" | "olivedrab" | "orange" | "orangered" | "orchid" | "palegoldenrod" | "palegreen" | "paleturquoise" | "palevioletred" | "papayawhip" | "peachpuff" | "peru" | "pink" | "plum" | "powderblue" | "rosybrown" | "royalblue" | "saddlebrown" | "salmon" | "sandybrown" | "seagreen" | "seashell" | "sienna" | "skyblue" | "slateblue" | "slategray" | "slategrey" | "snow" | "springgreen" | "steelblue" | "tan" | "thistle" | "tomato" | "turquoise" | "violet" | "wheat" | "whitesmoke" | "yellowgreen"

 "black" | "silver" | "gray" | "white" | "maroon" | "red" | "purple" | "fuchsia" | "green" | "lime" | "olive" | "yellow" | "navy" | "blue" | "teal" | "aqua" | "aliceblue" | "antiquewhite" | "aqua" | "aquamarine" | "azure" | "beige" | "bisque" | "black" | "blanchedalmond" | "blue" | "blueviolet" | "brown" | "burlywood" | "cadetblue" | "chartreuse" | "chocolate" | "coral" | "cornflowerblue" | "cornsilk" | "crimson" | "cyan" | "darkblue" | "darkcyan" | "darkgoldenrod" | "darkgray" | "darkgreen" | "darkgrey" | "darkkhaki" | "darkmagenta" | "darkolivegreen" | "darkorange" | "darkorchid" | "darkred" | "darksalmon" | "darkseagreen" | "darkslateblue" | "darkslategray" | "darkslategrey" | "darkturquoise" | "darkviolet" | "deeppink" | "deepskyblue" | "dimgray" | "dimgrey" | "dodgerblue" | "firebrick" | "floralwhite" | "forestgreen" | "fuchsia" | "gainsboro" | "ghostwhite" | "gold" | "goldenrod" | "gray" | "green" | "greenyellow" | "grey" | "honeydew" | "hotpink" | "indianred" | "indigo" | "ivory" | "khaki" | "lavender" | "lavenderblush" | "lawngreen" | "lemonchiffon" | "lightblue" | "lightcoral" | "lightcyan" | "lightgoldenrodyellow" | "lightgray" | "lightgreen" | "lightgrey" | "lightpink" | "lightsalmon" | "lightseagreen" | "lightskyblue" | "lightslategray" | "lightslategrey" | "lightsteelblue" | "lightyellow" | "lime" | "limegreen" | "linen" | "magenta" | "maroon" | "mediumaquamarine" | "mediumblue" | "mediumorchid" | "mediumpurple" | "mediumseagreen" | "mediumslateblue" | "mediumspringgreen" | "mediumturquoise" | "mediumvioletred" | "midnightblue" | "mintcream" | "mistyrose" | "moccasin" | "navajowhite" | "navy" | "oldlace" | "olive" | "olivedrab" | "orange" | "orangered" | "orchid" | "palegoldenrod" | "palegreen" | "paleturquoise" | "palevioletred" | "papayawhip" | "peachpuff" | "peru" | "pink" | "plum" | "powderblue" | "purple" | "red" | "rosybrown" | "royalblue" | "saddlebrown" | "salmon" | "sandybrown" | "seagreen" | "seashell" | "sienna" | "silver" | "skyblue" | "slateblue" | "slategray" | "slategrey" | "snow" | "springgreen" | "steelblue" | "tan" | "teal" | "thistle" | "tomato" | "turquoise" | "violet" | "wheat" | "white" | "whitesmoke" | "yellow" | "yellowgreen"

namespace S {
  export type IsString<T> =
>IsString : IsString<T>

    T extends string ? true : false;
>true : true
>false : false
  
  export type IsStringLiteral<T> =
>IsStringLiteral : IsStringLiteral<T>

    IsString<T> extends true
>true : true

      ? string extends T ? false : true
>false : false
>true : true

      : false
>false : false

  export type Cast<T> =
>Cast : Cast<T>

    A.Cast<T, string>
>A : any

  export type At<S, I> =
>At : At<S, I>

    Split<S> extends { [_ in A.Cast<I, number>]: infer X }
>A : any

      ? X
      : ""

  export type Split<T> =
>Split : Split<T>

    T extends `${infer H}${infer T}` ? [H, ...Split<T>] :
    T extends "" ? [] : [T]

  export type TrimedL<T> =
>TrimedL : TrimedL<T>

    T extends ` ${infer T}` ? TrimedL<T> : T

  export type TrimedR<T> =
>TrimedR : TrimedR<T>

    T extends `${infer T} ` ? TrimedL<T> : T

  export type Length<S> =
>Length : Length<S>

    Split<S>["length"]

  export type Shifted<S> =
>Shifted : Shifted<S>

    S extends `${infer _}${infer T}` ? T : never
}

export namespace N {
  export type Cast<T> = A.Cast<T, number>
>Cast : Cast<T>
>A : any

  export type NaturalNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
>NaturalNumbers : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

  export type WholeNumbers = [0, ...NaturalNumbers];
>WholeNumbers : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]

  export type WholeNumbersUnshifted = [-1, ...WholeNumbers];
>WholeNumbersUnshifted : [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
>-1 : -1
>1 : 1

  export type Increment<N> = A.Get<NaturalNumbers, N>
>Increment : Increment<N>
>A : any

  export type Decrement<N> = A.Get<WholeNumbersUnshifted, N>
>Decrement : Decrement<N>
>A : any
}

export namespace L {
  export type SlicedH<A, N> =
>SlicedH : SlicedH<A, N>

    N extends 0 ? [] :
    A extends [infer H, ...infer T] ? [H, ...SlicedH<T, N.Decrement<N>>] : 
>N : any

    never
}

export namespace Nd {
  export type IsLessThanOrEqual<A, B> =
>IsLessThanOrEqual : IsLessThanOrEqual<A, B>

    A extends 0 ? true :
>true : true

    B extends A.Get<L.SlicedH<N.WholeNumbers, N.Increment<A>>, number> ? false :
>A : any
>L : any
>N : any
>N : any
>false : false

    true
>true : true

  export type IsLessThan<A, B> = 
>IsLessThan : IsLessThan<A, B>

    A extends B ? false :
>false : false

    IsLessThanOrEqual<A, B>
}

export namespace Ns {
  export type ToN<T> =
>ToN : ToN<T>

    { [N in keyof N.WholeNumbers]:
>N : any

        T extends N ? N.WholeNumbers[N] : never
>N : any

    }[keyof N.WholeNumbers]
>N : any

  export type TrimL<T> =
>TrimL : TrimL<T>

    T extends `0${infer T}` ? TrimL<T> : T

  export type IsLessThanOrEqual<_A, _B, A = TrimL<_A>, B = TrimL<_B>> =
>IsLessThanOrEqual : IsLessThanOrEqual<_A, _B, A, B>

    Nd.IsLessThan<S.Length<A>, S.Length<B>> extends true ? true :
>Nd : any
>S : any
>S : any
>true : true
>true : true

    S.Length<A> extends S.Length<B>
>S : any
>S : any

      ? Nd.IsLessThan<ToN<S.At<A, 0>>, ToN<S.At<B, 0>>> extends true ? true :
>Nd : any
>S : any
>S : any
>true : true
>true : true

        S.At<A, 0> extends S.At<B, 0> ? IsLessThanOrEqual<S.Shifted<A>, S.Shifted<B>> :
>S : any
>S : any
>S : any
>S : any

        false :
>false : false

    false
>false : false
}


export namespace A {
  export type Cast<T, U> = T extends U ? T : U;
>Cast : Cast<T, U>

  export type Get<T, K> = K extends keyof T ? T[K] : never
>Get : Get<T, K>
}
