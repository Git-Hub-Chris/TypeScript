//// [tests/cases/compiler/inferenceOuterResultNotIncorrectlyInstantiatedWithInnerResult2.ts] ////

=== Performance Stats ===
Type Count: 1,000
Instantiation count: 2,500

=== inferenceOuterResultNotIncorrectlyInstantiatedWithInnerResult2.ts ===
class S<T> {
>S : S<T>
>  : ^^^^

  set: Set<T>;
>set : Set<T>
>    : ^^^^^^

  constructor(set: Set<T>) {
>set : Set<T>
>    : ^^^^^^

    this.set = set;
>this.set = set : Set<T>
>               : ^^^^^^
>this.set : Set<T>
>         : ^^^^^^
>this : this
>     : ^^^^
>set : Set<T>
>    : ^^^^^^
>set : Set<T>
>    : ^^^^^^
  }

  array() {
>array : () => S<T[]>
>      : ^^^^^^^^^^^^

    return new S(new Set([...this.set].map((item) => [item])));
>new S(new Set([...this.set].map((item) => [item]))) : S<T[]>
>                                                    : ^^^^^^
>S : typeof S
>  : ^^^^^^^^
>new Set([...this.set].map((item) => [item])) : Set<T[]>
>                                             : ^^^^^^^^
>Set : SetConstructor
>    : ^^^^^^^^^^^^^^
>[...this.set].map((item) => [item]) : T[][]
>                                    : ^^^^^
>[...this.set].map : <U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]
>                  : ^ ^^          ^^^     ^^^^^     ^^      ^^     ^^^^^^^^^^^^^       ^^^   ^^^^^^^^
>[...this.set] : T[]
>              : ^^^
>...this.set : T
>            : ^
>this.set : Set<T>
>         : ^^^^^^
>this : this
>     : ^^^^
>set : Set<T>
>    : ^^^^^^
>map : <U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]
>    : ^ ^^          ^^^     ^^^^^     ^^      ^^     ^^^^^^^^^^^^^       ^^^   ^^^^^^^^
>(item) => [item] : (item: T) => T[]
>                 : ^    ^^^^^^^^^^^
>item : T
>     : ^
>[item] : T[]
>       : ^^^
>item : T
>     : ^
  }
}

function sArray<T>(set: Set<T>) {
>sArray : <T>(set: Set<T>) => S<T[]>
>       : ^ ^^   ^^      ^^^^^^^^^^^
>set : Set<T>
>    : ^^^^^^

  return new S(new Set([...set].map((item) => [item])));
>new S(new Set([...set].map((item) => [item]))) : S<T[]>
>                                               : ^^^^^^
>S : typeof S
>  : ^^^^^^^^
>new Set([...set].map((item) => [item])) : Set<T[]>
>                                        : ^^^^^^^^
>Set : SetConstructor
>    : ^^^^^^^^^^^^^^
>[...set].map((item) => [item]) : T[][]
>                               : ^^^^^
>[...set].map : <U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]
>             : ^ ^^          ^^^     ^^^^^     ^^      ^^     ^^^^^^^^^^^^^       ^^^   ^^^^^^^^
>[...set] : T[]
>         : ^^^
>...set : T
>       : ^
>set : Set<T>
>    : ^^^^^^
>map : <U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]
>    : ^ ^^          ^^^     ^^^^^     ^^      ^^     ^^^^^^^^^^^^^       ^^^   ^^^^^^^^
>(item) => [item] : (item: T) => T[]
>                 : ^    ^^^^^^^^^^^
>item : T
>     : ^
>[item] : T[]
>       : ^^^
>item : T
>     : ^
}

